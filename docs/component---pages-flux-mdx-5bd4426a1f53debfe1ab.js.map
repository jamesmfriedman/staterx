{"version":3,"sources":["webpack:///../pages/flux.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"yeAMO,IAAMA,EAAe,Q,gMAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,QADR,QAGA,4MAA2L,0BAAYC,WAAW,KAAvB,OAA3L,KAAgP,0BAAYA,WAAW,KAAvB,OAAhP,KAAqS,0BAAYA,WAAW,KAAvB,SAArS,yDACA,iBAAQ,CACN,GAAM,oBADR,oBAGA,0JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8NAQL,wNACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,+SAaL,iBAAQ,CACN,GAAM,2BADR,2BAGA,6JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,oWAmBL,iBAAQ,CACN,GAAM,2BADR,2BAGA,yKAAwJ,0BAAYA,WAAW,KAAvB,eAAxJ,gFACA,qBAAG,0BAAYA,WAAW,KAAvB,eAAH,wFACA,8BACE,iBAAGA,WAAW,cAAd,kLAA8M,0BAAYA,WAAW,KAAvB,wBAA9M,MAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,o1B,8LA+BTJ,EAAWK,gBAAiB","file":"component---pages-flux-mdx-5bd4426a1f53debfe1ab.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/jamesmfriedman/Sites/staterx/docs-src/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"flux\"\n    }}>{`Flux`}</h1>\n    <p>{`StateRx optionally supports flux style architectures out of the box. Under the hood, all of the imperative calls are actually implemented using reducers, dispatchers, and actions. `}<inlineCode parentName=\"p\">{`get`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`set`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`reset`}</inlineCode>{` and other effects are actually just action creators.`}</p>\n    <h2 {...{\n      \"id\": \"handling-actions\"\n    }}>{`Handling actions`}</h2>\n    <p>{`A dispatch function and an observable of actions is available on every State Object so you can dispatch and subscribe accoringly.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { createValue } from 'staterx';\nconst myValue = createValue({default: 0});\n\nmyValue.action$.subscribe(action => console.log(action));\nmyValue.dispatch({ type: 'helloWorld' }); // logs {type: 'helloWorld'}\n`}</code></pre>\n    <p>{`If you're used to the actionCreator pattern, you can use effects to write your own actionCreators. The following example is functionally equivalent to the one above, just a bit more reusable.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { createValue } from 'staterx';\nconst myValue = createValue({\n  default: 0,\n  effects: ({ dispatch }) => ({\n    hellWorld: () => dispatch({ type: 'helloWorld' })\n  })\n});\n\nmyValue.action$.subscribe(action => console.log(action));\nmyValue.helloWorld(); // logs {type: 'helloWorld'}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-your-own-reducer\"\n    }}>{`Adding your own reducer`}</h2>\n    <p>{`You can extend the built in reducer functionality with a reducer of your own. These are executed after any of the built in reducers.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const myValue = createValue({\n  default: 0,\n  reducer: (state, action) => {\n    switch (action.type) {\n      case 'increment':\n        return state + 1;\n      case 'decrement':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n});\n\nmyValue.dispatch({ type: 'increment' });\nconsole.log(myValue.get()); // logs 1;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"creating-a-global-store\"\n    }}>{`Creating a global store`}</h2>\n    <p>{`One of the main differences between StateRx and a typical Flux architecture is that each State Object has its own dispatcher. StateRx includes a `}<inlineCode parentName=\"p\">{`createStore`}</inlineCode>{` factory that can combine multiple State Objects into a single global store.`}</p>\n    <p><inlineCode parentName=\"p\">{`createStore`}</inlineCode>{` takes an object of strings pointing to either StateRx Objects or plain Observables.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`StateRx has alpha support for Redux Dev Tools so you can inspect your current state and view changes over time. Just install the Chrome Redux Dev Tools extension and then use `}<inlineCode parentName=\"p\">{`connectReduxDevTools`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { createStore, createValue, connectReduxDevTools } from 'staterx';\n\n// You can optionally pass a name to identify your StateRx\n// Object. If not, a name will be generated for you.\nconst myValue = createValue({ key: 'myValue', default: 0 });\nconst anotherValue = createValue({ key: 'anotherValue', default: 'Hello' });\n\nconst store = createStore({\n  [myValue.key]: myValue,\n  [anotherValue.key]: anoterValue\n});\n\n// optionally connect redux-dev-tools\nconnectReduxDevTools(store);\n\n// you can subscribe to all store actions\nstore.action$.subscribe(action => console.log(action));\n\n// dispatch actions across ALL branches of your state\nstore.dispatch({ type: 'hello' });\n\n// Subscribe to any changes to global state\n// Logs {myValue: 0, anotherValue: 'Hello'}\nstore.state$.subscribe(state => console.log(state));\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}