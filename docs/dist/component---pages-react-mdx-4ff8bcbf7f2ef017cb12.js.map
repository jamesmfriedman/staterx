{"version":3,"sources":["webpack:///../pages/react.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","__position","__code","__scope","Playground","useRx","counter","todos","colors","ComponentA","ComponentB","SetColors","count","state$","numCalls","callCount$","onClick","decrement","increment","reset","todo","byId","htmlFor","id","type","value","checked","onChange","evt","merge","completed","currentTarget","text","isMDXComponent"],"mappings":"wtCASO,IAAMA,EAAe,Q,iMAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,UAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAI5E,iBAAQ,CACN,GAAM,SADR,SAGA,8EAA6D,0BAAYC,WAAW,KAAvB,SAA7D,kIAAiP,0BAAYA,WAAW,KAAvB,UAAjP,mBAAuT,0BAAYA,WAAW,KAAvB,cAAvT,gBACA,gGACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,yiBAgBL,iBAAQ,CACN,GAAM,SADR,SAGA,qBAAG,0BAAYA,WAAW,KAAvB,SAAH,yFAA8I,0BAAYA,WAAW,KAAvB,YAA9I,gLACA,qBAAG,sBAAQA,WAAW,KAAnB,aAAH,4GAA6J,0BAAYA,WAAW,KAAvB,aAA7J,4MACA,YAAC,IAAD,CAAYC,WAAY,EAAGC,OAAQ,8bAA+bC,SAAO,GACveL,QACAH,kBACAS,eACAC,UACAC,YACAC,UACAC,WACAC,eACAC,eACAC,eAVue,gBAWvehB,IAXue,EAYveH,eAZue,GAateO,QAAQ,eAAc,WAAM,IACpBa,EAASP,YAAMC,IAAQO,QADH,GAEpBC,EAAYT,YAAMC,IAAQS,WAAY,GAFlB,GAI3B,OAAO,gCACX,sBAAQC,QAASV,IAAQW,WAAzB,eAGA,sBAAQD,QAASV,IAAQY,WAAzB,eAGA,sBAAQF,QAASV,IAAQa,OAAzB,SAGA,sBACE,gCAAYP,GACZ,oCAAgBE,QAIlB,iBAAQ,CACN,GAAM,wCADR,wCAGA,iNAAgM,0BAAYd,WAAW,KAAvB,SAAhM,6GACA,+CAA8B,0BAAYA,WAAW,KAAvB,eAA9B,+BAAqH,0BAAYA,WAAW,KAAvB,eAArH,uFAAoQ,0BAAYA,WAAW,KAAvB,QAApQ,qEAA0X,0BAAYA,WAAW,KAAvB,SAA1X,8BACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,mQAUL,YAAC,IAAD,CAAYC,WAAY,EAAGC,OAAQ,ydAA4dC,SAAO,GACpgBL,QACAH,kBACAS,eACAC,UACAC,YACAC,UACAC,WACAC,eACAC,eACAC,eAVogB,gBAWpgBhB,IAXogB,EAYpgBH,eAZogB,GAangBO,QAAQ,eAAc,WACrB,IACOqB,EAAQf,aAAM,kBAAME,IAAMc,KADtB,OACgC,CADhC,MADgB,GAI3B,OAAKD,EAIE,qBAAOE,QAASF,EAAKG,IAC9B,qBAAOA,GAAIH,EAAKG,GAAIC,KAAK,WAAWC,MAAOL,EAAKM,QAASC,SAAU,SAAAC,GAAG,OAAIrB,IAAMsB,MAAN,OAAiBT,GAAjB,IACpEU,UAAWF,EAAIG,cAAcL,cAElCN,EAAKY,MAPK,qDAUb,iBAAQ,CACN,GAAM,iCADR,iCAGA,uNAAsM,0BAAYhC,WAAW,KAAvB,SAAtM,kBAA0Q,kBAAIA,WAAW,KAAf,SAA1Q,MACA,0VACA,4KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4yBA4CL,YAAC,IAAD,CAAYC,WAAY,EAAGC,OAAQ,gDAAiDC,SAAO,GACzFL,QACAH,kBACAS,eACAC,UACAC,YACAC,UACAC,WACAC,eACAC,eACAC,eAVyF,gBAWzFhB,IAXyF,EAYzFH,eAZyF,GAaxFO,QAAQ,cACb,YAAC,IAAD,CAAWA,QAAQ,cACnB,YAAC,IAAD,CAAYA,QAAQ,eACpB,YAAC,IAAD,CAAYA,QAAQ,sB,+LAMtBH,EAAWqC,gBAAiB","file":"component---pages-react-mdx-4ff8bcbf7f2ef017cb12.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/jamesmfriedman/Sites/staterx/docs/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { Playground } from 'docz';\nimport { useRx } from 'staterx';\nimport { counter, todos, colors, ComponentA, ComponentB, SetColors } from './examples';\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h1 {...{\n      \"id\": \"react\"\n    }}>{`React`}</h1>\n    <p>{`StateRx has built in React support through hooks. The `}<inlineCode parentName=\"p\">{`useRx`}</inlineCode>{` hook actually work with ANY Observable, not just StateRx Objects. The following example creates a value and consumes both the `}<inlineCode parentName=\"p\">{`state$`}</inlineCode>{` and the custom `}<inlineCode parentName=\"p\">{`callCount$`}</inlineCode>{` Observable.`}</p>\n    <p>{`First, lets create a StateRx Objects to consume in our React component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { createValue, useRx } from 'staterx';\nimport { scan } from 'rxjs/operators';\n\nconst counter = createValue(0, {\n  effects: ({ state$ }) => ({\n    // here we create two functions that describe how we want to change our value\n    increment: () => counter.set(val => val + 1),\n    decrement: () => counter.set(val => val - 1),\n    // here we create an observable that can keep count of the total number of\n    // times our counter has changed, regardless of direction\n    callCount$: state$.pipe(scan(acc => acc + 1, -1))\n  })\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"userx\"\n    }}>{`useRx`}</h2>\n    <p><inlineCode parentName=\"p\">{`useRx`}</inlineCode>{` takes two arguments, an Observable and an optional default value. Similar to React's `}<inlineCode parentName=\"p\">{`useState`}</inlineCode>{`, it returns an array. The first item in the array is the value, however, the second value is actually an error in the event that our observable has an unrecoverable error.`}</p>\n    <p><strong parentName=\"p\">{`Attention`}</strong>{` Since Observables don't always have default values, be aware that your state's value might initially be `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{` on the first render since subscriptions in RxJS are async. Typescript will alert you of this potential issue, but for non Typescript users be aware that passing a default value is always a safe idea.`}</p>\n    <Playground __position={0} __code={'() => {\\n  const [count] = useRx(counter.state$)\\n  const [numCalls] = useRx(counter.callCount$, 0) // passing a default value\\n  return (\\n    <>\\n      <button onClick={counter.decrement}>- Decrement</button>\\n      <button onClick={counter.increment}>+ Increment</button>\\n      <button onClick={counter.reset}>Reset</button>\\n      <ul>\\n        <li>Count: {count}</li>\\n        <li>Num Calls: {numCalls}</li>\\n      </ul>\\n    </>\\n  )\\n}'} __scope={{\n      props,\n      DefaultLayout,\n      Playground,\n      useRx,\n      counter,\n      todos,\n      colors,\n      ComponentA,\n      ComponentB,\n      SetColors,\n      DefaultLayout,\n      _frontmatter\n    }} mdxType=\"Playground\">{() => {\n        const [count] = useRx(counter.state$);\n        const [numCalls] = useRx(counter.callCount$, 0); // passing a default value\n\n        return <>\n    <button onClick={counter.decrement}>\n      - Decrement\n    </button>\n    <button onClick={counter.increment}>\n      + Increment\n    </button>\n    <button onClick={counter.reset}>\n      Reset\n    </button>\n    <ul>\n      <li>Count: {count}</li>\n      <li>Num Calls: {numCalls}</li>\n    </ul>\n  </>;\n      }}</Playground>\n    <h2 {...{\n      \"id\": \"memoization-and-observable-factories\"\n    }}>{`Memoization and Observable Factories`}</h2>\n    <p>{`There are plenty of situations where consuming an effect requires passing some parameters to create an Observable. A basic use case is selecting an item by id. For these situations the `}<inlineCode parentName=\"p\">{`useRx`}</inlineCode>{` hook can handle memoization. Just pass a function that returns an Observable and a list of dependencies.`}</p>\n    <p>{`The example below uses `}<inlineCode parentName=\"p\">{`createItems`}</inlineCode>{` to create a list of todos. `}<inlineCode parentName=\"p\">{`createItems`}</inlineCode>{` comes with a bunch of useful built in effects, in this case we're going to use the `}<inlineCode parentName=\"p\">{`byId`}</inlineCode>{` effect. The example below is editable, you can modify the id and `}<inlineCode parentName=\"p\">{`useRx`}</inlineCode>{` will respond accordingly.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { creatItems, useRx } from 'staterx';\n\nconst todos = createItems({\n  '1': {id: '1', text: 'First Todo', completed: false},\n  '2': {id: '2', text: 'Second Todo', completed: false},\n  '3': {id: '3', text: 'Third Todo', completed: false},\n});\n`}</code></pre>\n    <Playground __position={1} __code={'() => {\\n  const id = \\'1\\'\\n  const [todo] = useRx(() => todos.byId(id), [id])\\n\\n  if (!todo) {\\n    return <>Todo Not Found</>\\n  }\\n\\n  return (\\n    <label htmlFor={todo.id}>\\n      <input\\n        id={todo.id}\\n        type=\\\"checkbox\\\"\\n        value={todo.checked}\\n        onChange={evt =>\\n          todos.merge({\\n            ...todo,\\n            completed: evt.currentTarget.checked,\\n          })\\n        }\\n      />\\n      {todo.text}\\n    </label>\\n  )\\n}'} __scope={{\n      props,\n      DefaultLayout,\n      Playground,\n      useRx,\n      counter,\n      todos,\n      colors,\n      ComponentA,\n      ComponentB,\n      SetColors,\n      DefaultLayout,\n      _frontmatter\n    }} mdxType=\"Playground\">{() => {\n        const id = '1';\n        const [todo] = useRx(() => todos.byId(id), [id]);\n\n        if (!todo) {\n          return <>Todo Not Found</>;\n        }\n\n        return <label htmlFor={todo.id}>\n      <input id={todo.id} type=\"checkbox\" value={todo.checked} onChange={evt => todos.merge({ ...todo,\n            completed: evt.currentTarget.checked\n          })} />\n      {todo.text}\n    </label>;\n      }}</Playground>\n    <h2 {...{\n      \"id\": \"cross-component-communication\"\n    }}>{`Cross Component Communication`}</h2>\n    <p>{`There are many different ways to share state between components such as Context, Providers, Lifted State, Global Stores. StateRx makes this behavior dummy proof. As long as you are using the `}<inlineCode parentName=\"p\">{`useRx`}</inlineCode>{` hook, it just `}<em parentName=\"p\">{`works`}</em>{`. `}</p>\n    <p>{`Here is a contrived example. We have three components, we can use the set method of our StateRx Objects to update the value, and two other components can respond accordingly. To make the example a little more dynamic, we've added a delay to the second observable so ComponentB will change color slightly after ComponentA.`}</p>\n    <p>{`Components do not have to be parents, children, siblings, or even in the same files. They will re-render whenever the Observable emits a new value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useRx } from 'staterx';\nimport { delay } from 'rxjs/operators';\n\nconst colors = createValue('red');\n\nexport function ComponentA() {\n  const [backgroundColor] = useRx(colors.state$);\n  return (\n    <div\n      className=\"colorExample\"\n      style={{\n        backgroundColor\n      }}\n    >\n      A\n    </div>\n  );\n}\n\nexport function ComponentB() {\n  const [backgroundColor] = useRx(() => colors.state$.pipe(delay(500)));\n  return (\n    <div\n      className=\"colorExample\"\n      style={{\n        backgroundColor\n      }}\n    >\n      B\n    </div>\n  );\n}\n\nexport function SetColors() {\n  return (\n    <>\n      <button onClick={() => colors.set('red')}>Make it Red</button>\n      <button onClick={() => colors.set('blue')}>Make it Blue</button>\n    </>\n  );\n}\n`}</code></pre>\n    <Playground __position={2} __code={'<SetColors />\\n<ComponentA />\\n<ComponentB />'} __scope={{\n      props,\n      DefaultLayout,\n      Playground,\n      useRx,\n      counter,\n      todos,\n      colors,\n      ComponentA,\n      ComponentB,\n      SetColors,\n      DefaultLayout,\n      _frontmatter\n    }} mdxType=\"Playground\">\n  <SetColors mdxType=\"SetColors\" />\n  <ComponentA mdxType=\"ComponentA\" />\n  <ComponentB mdxType=\"ComponentB\" />\n    </Playground>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}