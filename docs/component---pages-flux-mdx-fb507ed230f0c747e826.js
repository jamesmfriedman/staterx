(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{tM4a:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return l})),n.d(t,"default",(function(){return i}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk");var a=n("/FXl"),o=n("TjRS");n("aD51");function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"pages/flux.mdx"}});var c={_frontmatter:l},s=o.a;function i(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(a.b)(s,r({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"flux"},"Flux"),Object(a.b)("p",null,"StateRx optionally supports flux style architectures out of the box. Under the hood, all of the imperative calls are actually implemented using reducers, dispatchers, and actions. ",Object(a.b)("inlineCode",{parentName:"p"},"get"),", ",Object(a.b)("inlineCode",{parentName:"p"},"set"),", ",Object(a.b)("inlineCode",{parentName:"p"},"reset")," and other effects are actually just action creators."),Object(a.b)("h2",{id:"handling-actions"},"Handling actions"),Object(a.b)("p",null,"A dispatch function and an observable of actions is available on every State Object so you can dispatch and subscribe accoringly."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import { createValue } from 'staterx';\nconst myValue = createValue(0);\n\nmyValue.action$.subscribe(action => console.log(action));\nmyValue.dispatch({ type: 'helloWorld' }); // logs {type: 'helloWorld'}\n")),Object(a.b)("p",null,"If you're used to the actionCreator pattern, you can use effects to write your own actionCreators. The following example is functionally equivalent to the one above, just a bit more reusable."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import { createValue } from 'staterx';\nconst myValue = createValue(0, {\n  effects: ({ dispatch }) => ({\n    hellWorld: () => dispatch({ type: 'helloWorld' })\n  })\n});\n\nmyValue.action$.subscribe(action => console.log(action));\nmyValue.helloWorld(); // logs {type: 'helloWorld'}\n")),Object(a.b)("h2",{id:"adding-your-own-reducer"},"Adding your own reducer"),Object(a.b)("p",null,"You can extend the built in reducer functionality with a reducer of your own. These are executed after any of the built in reducers."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const myValue = createValue(0, {\n  reducer: (state, action) => {\n    switch (action.type) {\n      case 'increment':\n        return state + 1;\n      case 'decrement':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n});\n\nmyValue.dispatch({ type: 'increment' });\nconsole.log(myValue.get()); // logs 1;\n")),Object(a.b)("h2",{id:"creating-a-global-store"},"Creating a global store"),Object(a.b)("p",null,"One of the main differences between StateRx and a typical Flux architecture is that each State Object has its own dispatcher. StateRx includes a ",Object(a.b)("inlineCode",{parentName:"p"},"createStore")," factory that can combine multiple State Objects into a single global store."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"createStore")," takes an object of strings pointing to either StateRx Objects or plain Observables."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"StateRx has alpha support for Redux Dev Tools so you can inspect your current state and view changes over time. Just install the Chrome Redux Dev Tools extension and then use ",Object(a.b)("inlineCode",{parentName:"p"},"connectDevTools"),".")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import { createStore, createValue, connectDevTools } from 'staterx';\n\n// You can optionally pass a name to identify your StateRx\n// Object. If not, a name will be generated for you.\nconst myValue = createValue(0, { name: 'myValue' });\nconst anotherValue = createValue('Hello', { name: 'anotherValue' });\n\nconst store = createStore({\n  [myValue.name]: myValue,\n  [anotherValue.name]: anoterValue\n});\n\n// optionally connect redux-dev-tools\nconnectDevTools(store);\n\n// you can subscribe to all store actions\nstore.action$.subscribe(action => console.log(action));\n\n// dispatch actions across ALL branches of your state\nstore.dispatch({ type: 'hello' });\n\n// Subscribe to any changes to global state\n// Logs {myValue: 0, anotherValue: 'Hello'}\nstore.state$.subscribe(state => console.log(state));\n")))}void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"pages/flux.mdx"}}),i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---pages-flux-mdx-fb507ed230f0c747e826.js.map